getColor <- function(dat) {
sapply(dat$sex, function(s) {
ifelse(s %in% c('M'), "blue", "red")
})
}
icons <- awesomeIcons(
icon = 'ios-close',
iconColor = 'black',
library = 'ion',
markerColor = getColor(dat)
)
balto_map <- leaflet(dat) %>%
addTiles() %>%
addAwesomeMarkers(~lng, ~lat, icon=icons, label=~as.character(sex)) %>%
setView(lat=39.29, lng=-76.61, zoom=11)
balto_map
getColor <- function(dat) {
sapply(dat$sex, function(s) {
ifelse(s %in% c(M), "blue", "red")
})
}
icons <- awesomeIcons(
icon = 'ios-close',
iconColor = 'black',
library = 'ion',
markerColor = getColor(dat)
)
getColor <- function(dat) {
sapply(dat$sex, function(s) {
print(s)
ifelse(s %in% c("M"), "blue", "red")
})
}
icons <- awesomeIcons(
icon = 'ios-close',
iconColor = 'black',
library = 'ion',
markerColor = getColor(dat)
)
balto_map <- leaflet(dat) %>%
addTiles() %>%
addAwesomeMarkers(~lng, ~lat, icon=icons, label=~as.character(sex)) %>%
setView(lat=39.29, lng=-76.61, zoom=11)
balto_map
getColor <- function(dat) {
sapply(dat$sex, function(s) {
print(s)
ifelse(s %in% c("F"), "red", "blue")
})
}
icons <- awesomeIcons(
icon = 'ios-close',
iconColor = 'black',
library = 'ion',
markerColor = getColor(dat)
)
balto_map <- leaflet(dat) %>%
addTiles() %>%
addAwesomeMarkers(~lng, ~lat, icon=icons, label=~as.character(sex)) %>%
setView(lat=39.29, lng=-76.61, zoom=11)
balto_map
getColor <- function(dat) {
sapply(dat$sex, function(s) {
print(s)
ifelse(s = "F", "red", "blue")
})
}
icons <- awesomeIcons(
icon = 'ios-close',
iconColor = 'black',
library = 'ion',
markerColor = getColor(dat)
)
getColor <- function(dat) {
sapply(dat$sex, function(s) {
print(s)
ifelse(s == "F", "red", "blue")
})
}
icons <- awesomeIcons(
icon = 'ios-close',
iconColor = 'black',
library = 'ion',
markerColor = getColor(dat)
)
balto_map <- leaflet(dat) %>%
addTiles() %>%
addAwesomeMarkers(~lng, ~lat, icon=icons, label=~as.character(sex)) %>%
setView(lat=39.29, lng=-76.61, zoom=11)
balto_map
getColor <- function(dat) {
sapply(dat$sex, function(s) {
print(s)
ifelse(s == "F", "red", "blue")
})
}
icons <- awesomeIcons(
icon = 'ios-close',
iconColor = 'black',
library = 'ion',
markerColor = getColor(dat)
)
pal <- colorFactor(c("blue", "red"), domain = c("M", "F"))
leaflet(dat) %>% addTiles() %>%
addCircleMarkers(
radius = 6,
color = ~pal(type),
stroke = FALSE, fillOpacity = 0.5
)
getColor <- function(dat) {
sapply(dat$sex, function(s) {
print(s)
ifelse(s == "F", "red", "blue")
})
}
icons <- awesomeIcons(
icon = 'ios-close',
iconColor = 'black',
library = 'ion',
markerColor = getColor(dat)
)
pal <- colorFactor(c("blue", "red"), domain = c("M", "F"))
balto_map <- leaflet(dat) %>%
addCircleMarkers(
radius = 6,
color = ~pal(sex),
stroke = FALSE, fillOpacity = 0.5
)
#addTiles() %>%
#(~lng, ~lat, icon=icons, label=~as.character(sex)) %>%
#setView(lat=39.29, lng=-76.61, zoom=11)
balto_map
getColor <- function(dat) {
sapply(dat$sex, function(s) {
print(s)
ifelse(s == "F", "red", "blue")
})
}
icons <- awesomeIcons(
icon = 'ios-close',
iconColor = 'black',
library = 'ion',
markerColor = getColor(dat)
)
pal <- colorFactor(c("blue", "red"), domain = c("M", "F"))
balto_map <- leaflet(dat) %>%
addTiles() %>%
setView(lat=39.29, lng=-76.61, zoom=11) %>%
addCircleMarkers(
radius = 6,
color = ~pal(sex),
stroke = FALSE, fillOpacity = 0.5
) %>%
#(~lng, ~lat, icon=icons, label=~as.character(sex)) %>%
balto_map
getColor <- function(dat) {
sapply(dat$sex, function(s) {
print(s)
ifelse(s == "F", "red", "blue")
})
}
icons <- awesomeIcons(
icon = 'ios-close',
iconColor = 'black',
library = 'ion',
markerColor = getColor(dat)
)
pal <- colorFactor(c("blue", "red"), domain = c("M", "F"))
balto_map <- leaflet(dat) %>%
addTiles() %>%
setView(lat=39.29, lng=-76.61, zoom=11) %>%
addCircleMarkers(
radius = 6,
color = ~pal(sex),
stroke = FALSE, fillOpacity = 0.5
)
#(~lng, ~lat, icon=icons, label=~as.character(sex)) %>%
balto_map
getColor <- function(dat) {
sapply(dat$sex, function(s) {
print(s)
ifelse(s == "F", "red", "blue")
})
}
icons <- awesomeIcons(
icon = 'ios-close',
iconColor = 'black',
library = 'ion',
markerColor = getColor(dat)
)
pal <- colorFactor(c("blue", "red"), domain = c("M", "F"))
balto_map <- leaflet(dat) %>%
addTiles() %>%
setView(lat=39.29, lng=-76.61, zoom=11) %>%
addCircleMarkers(
radius = 6,
color = ~pal(sex),
stroke = FALSE, fillOpacity = 0.5
) %>%
(~lng, ~lat, label=~as.character(sex)) %>%
getColor <- function(dat) {
sapply(dat$sex, function(s) {
print(s)
ifelse(s == "F", "red", "blue")
})
}
icons <- awesomeIcons(
icon = 'ios-close',
iconColor = 'black',
library = 'ion',
markerColor = getColor(dat)
)
pal <- colorFactor(c("blue", "red"), domain = c("M", "F"))
balto_map <- leaflet(dat) %>%
addTiles() %>%
setView(lat=39.29, lng=-76.61, zoom=11) %>%
addCircleMarkers(
radius = 6,
color = ~pal(sex),
stroke = FALSE, fillOpacity = 0.5
) %>%
label=~as.character(sex)
getColor <- function(dat) {
sapply(dat$sex, function(s) {
print(s)
ifelse(s == "F", "red", "blue")
})
}
icons <- awesomeIcons(
icon = 'ios-close',
iconColor = 'black',
library = 'ion',
markerColor = getColor(dat)
)
pal <- colorFactor(c("blue", "red"), domain = c("M", "F"))
balto_map <- leaflet(dat) %>%
addTiles() %>%
setView(lat=39.29, lng=-76.61, zoom=11) %>%
addCircleMarkers(
radius = 6,
color = ~pal(sex),
stroke = FALSE, fillOpacity = 0.5
) %>%
(~lng, ~lat, icon=icons, label=~as.character(sex)) %>%
getColor <- function(dat) {
sapply(dat$sex, function(s) {
print(s)
ifelse(s == "F", "red", "blue")
})
}
icons <- awesomeIcons(
icon = 'ios-close',
iconColor = 'black',
library = 'ion',
markerColor = getColor(dat)
)
pal <- colorFactor(c("blue", "red"), domain = c("M", "F"))
balto_map <- leaflet(dat) %>%
addTiles() %>%
setView(lat=39.29, lng=-76.61, zoom=11) %>%
addCircleMarkers(
radius = 6,
color = ~pal(sex),
stroke = FALSE, fillOpacity = 0.5
)
balto_map
getColor <- function(dat) {
sapply(dat$sex, function(s) {
print(s)
ifelse(s == "F", "red", "blue")
})
}
icons <- awesomeIcons(
icon = 'ios-close',
iconColor = 'black',
library = 'ion',
markerColor = getColor(dat)
)
pal <- colorFactor(c("blue", "red"), domain = c("M", "F"))
balto_map <- leaflet(dat) %>%
addTiles() %>%
setView(lat=39.29, lng=-76.61, zoom=11) %>%
addCircleMarkers(
radius = 6,
color = ~pal(sex),
stroke = TRUE, fillOpacity = 0.5
)
balto_map
getColor <- function(dat) {
sapply(dat$sex, function(s) {
print(s)
ifelse(s == "F", "red", "blue")
})
}
icons <- awesomeIcons(
icon = 'ios-close',
iconColor = 'black',
library = 'ion',
markerColor = getColor(dat)
)
pal <- colorFactor(c("red", "blue"), domain = c("M", "F"))
balto_map <- leaflet(dat) %>%
addTiles() %>%
setView(lat=39.29, lng=-76.61, zoom=11) %>%
addCircleMarkers(
radius = 6,
color = ~pal(sex),
stroke = FALSE, fillOpacity = 0.5
)
balto_map
balto_map <- leaflet(dat) %>%
addTiles() %>%
setView(lat=39.29, lng=-76.61, zoom=11) %>%
addCircleMarkers(
radius = 6,
color = ~pal(sex),
stroke = FALSE, fillOpacity = 0.5
)
balto_map
pal <- colorFactor(c("red", "blue"), domain = c("M", "F"))
balto_map <- leaflet(dat) %>%
addTiles() %>%
setView(lat=39.29, lng=-76.61, zoom=11) %>%
addCircleMarkers(
radius = 6,
color = ~pal(sex),
stroke = FALSE, fillOpacity = 0.5
)
balto_map
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(lubridate)
library(caret)
library(broom)
library(pracma)
library(caret)
library(rpart)
library(rpart.plot)
forest_control <- trainControl(method="cv", classProbs = TRUE, savePredictions = TRUE)
forest_fit <- train(High~., data=prediction_set, method="rf", trControl=forest_control)
# Step1: Begin with a small cp.
set.seed(123)
outcome_df <- crypto_tab %>%
mutate(Direction = ifelse(diff>0, "up", "down"))
knitr::opts_chunk$set(echo = TRUE)
library(tidyverse)
library(lubridate)
library(caret)
library(broom)
library(pracma)
library(caret)
library(rpart)
library(rpart.plot)
bitcoin_tab <- read_csv("datasets/bitcoin_price.csv")
litecoin_tab <- read_csv("datasets/litecoin_price.csv")
ethereum_tab <- read_csv("datasets/ethereum_price.csv")
bitcoin_tab <- mutate(bitcoin_tab, coin_type="bitcoin")
litecoin_tab <- mutate(litecoin_tab, coin_type="litecoin")
ethereum_tab <- mutate(ethereum_tab, coin_type="ethereum")
crypto_tab <- bitcoin_tab %>%
rbind(litecoin_tab) %>%
rbind(ethereum_tab) %>%
mutate(Date=mdy(Date)) %>%
arrange(desc(Date))
head(crypto_tab)
crypto_tab = crypto_tab %>%
mutate(close_ratio=(Close-Low)/(High-Low)) %>%
mutate(spread=High-Low) %>%
mutate(vol_mult = Volume/spread) %>%
mutate(diff=Close-Open) %>%
drop_na
head(crypto_tab)
print("Bitcoin Analysis:")
bitcoin = crypto_tab %>%
filter(coin_type=='bitcoin')
cat("Volume Min - ", min(bitcoin$Volume), "\n")
cat("Volume Max - ", max(bitcoin$Volume), "\n")
cat("Spread Min - ", min(bitcoin$spread), "\n")
cat("Spread Max - ", max(bitcoin$spread), "\n")
cat("Close Ratio Mean - ", mean(bitcoin$close_ratio), "\n")
cat("Close Ratio Median - ", median(bitcoin$close_ratio), "\n")
cat("Close Ratio Variance - ", var(bitcoin$close_ratio), "\n")
cat("\n")
print("Ethereum Analysis:")
ethereum = crypto_tab %>%
filter(coin_type=='ethereum')
cat("Volume Min - ", min(ethereum$Volume), "\n")
cat("Volume Max - ", max(ethereum$Volume), "\n")
cat("Spread Min - ", min(ethereum$spread), "\n")
cat("Spread Max - ", max(ethereum$spread), "\n")
cat("Close Ratio Mean - ", mean(ethereum$close_ratio), "\n")
cat("Close Ratio Median - ", median(ethereum$close_ratio), "\n")
cat("Close Ratio Variance - ", var(ethereum$close_ratio), "\n")
cat("\n")
print("Litecoin Analysis:")
litecoin = crypto_tab %>%
filter(coin_type=='litecoin')
cat("Volume Min - ", min(litecoin$Volume), "\n")
cat("Volume Max - ", max(litecoin$Volume), "\n")
cat("Spread Min - ", min(litecoin$spread), "\n")
cat("Spread Max - ", max(litecoin$spread), "\n")
cat("Close Ratio Mean - ", mean(litecoin$close_ratio), "\n")
cat("Close Ratio Median - ", median(litecoin$close_ratio), "\n")
cat("Close Ratio Variance - ", var(litecoin$close_ratio), "\n")
crypto_tab %>%
ggplot(aes(x=Date, y=Open, color=coin_type)) +
geom_line()  +
labs(title = "Opening Price over Time",
x = "Date",
y = "Open")
crypto_tab %>%
ggplot(aes(x=Date, y=Close, color=coin_type)) +
geom_line()  +
labs(title = "Closing Price over Time",
x = "Date",
y = "Closing")
crypto_tab %>%
group_by(coin_type) %>%
arrange(desc(diff)) %>%
ggplot(aes(x=Date, y=diff, color=coin_type)) +
geom_line() +
labs(title = "Difference in Closing Price vs Opening Price over Time",
x = "Date",
y = "Difference")
crypto_tab %>%
group_by(coin_type) %>%
arrange(desc(spread)) %>%
ggplot(aes(x=Date, y=spread, color=coin_type)) +
geom_line() +
labs(title = "Spread over Time",
x = "Date",
y = "Spread")
crypto_tab %>%
ggplot(aes(x=Date, y=close_ratio, color=coin_type)) +
geom_point() +
geom_smooth(method='lm') +
labs(title = "Close Ratio over Time",
x = "Date",
y = "Close Ratio")
crypto_tab %>%
ggplot(aes(x=Date, y=Volume, color=coin_type)) +
geom_line() +
labs(title = "Volume over Time",
x = "Date",
y = "Volume")
crypto_tab = crypto_tab %>%
filter(Date >= "2017-01-01")
head(crypto_tab)
crypto_tab %>%
ggplot(aes(x=Date, y=Volume, color=coin_type)) +
geom_line() +
geom_smooth() +
labs(title = "Volume over Time",
x = "Date",
y = "Volume")
crypto_tab %>%
group_by(coin_type) %>%
arrange(desc(spread)) %>%
ggplot(aes(x=Date, y=spread, color=coin_type)) +
geom_line() +
geom_smooth() +
labs(title = "Spread over Time",
x = "Date",
y = "Spread")
crypto_tab %>%
group_by(coin_type) %>%
ggplot(aes(x=spread, y=Volume, color=coin_type)) +
geom_line() +
geom_smooth(method='lm') +
labs(title = "Spread vs. Volume",
x = "Spread",
y = "Volume")
reg_model <- lm(Volume~spread, data=crypto_tab)
reg_model_stats <- reg_model %>%
tidy()
reg_model_stats
crypto_tab %>%
group_by(coin_type) %>%
ggplot(aes(x=spread, y=vol_mult, color=coin_type)) +
geom_point() +
geom_smooth(method='lm') +
labs(title = "Spread vs. Volume Multiplier",
x = "Spread",
y = "Volume Multiplier")
# Step1: Begin with a small cp.
set.seed(123)
outcome_df <- crypto_tab %>%
mutate(Direction = ifelse(diff>0, "up", "down"))
outcome_df
predictor_df <- outcome_df %>%
slice(4:n())
prediction_set <- predictor_df %>%
select(-Open, -Low, -Close, -Volume, -`Market Cap`, -close_ratio, -spread)
index <- createDataPartition(y=prediction_set$High, p=0.8, list=FALSE)
data_train <- prediction_set[index,]
data_test <- prediction_set[-index,]
tree <- rpart(High~Date+coin_type, data = data_train, control = rpart.control(cp = 0.0001))
# Step2: Pick the tree size that minimizes misclassification rate (i.e. prediction error).
# Prediction error rate in training data = Root node error * rel error * 100%
# Prediction error rate in cross-validation = Root node error * xerror * 100%
# Hence we want the cp value (with a simpler tree) that minimizes the xerror.
printcp(tree)
bestcp <- tree$cptable[which.min(tree$cptable[,"xerror"]),"CP"]
# Step3: Prune the tree using the best cp.
tree.pruned <- prune(tree, cp = bestcp)
prp(tree.pruned, faclen = 0, cex = 0.7, extra = 1)
#prediction_set$High <- factor(prediction_set$High)
train_control <- trainControl(method="cv", number=10)
tree_fit <- train(High~Date+coin_type, data=prediction_set, method="rpart", trControl=train_control, tuneLength=10)
tree_fit
forest_control <- trainControl(method="cv", classProbs = TRUE, savePredictions = TRUE)
forest_fit <- train(High~., data=prediction_set, method="rf", trControl=forest_control)
